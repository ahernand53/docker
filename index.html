<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Guía del Curso de Docker</title>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="57x57" href="assets/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="assets/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="assets/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="assets/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="assets/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="assets/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="assets/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="assets/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="assets/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="32x32" href="assets/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="192x192" href="assets/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="16x16" href="assets/favicon-16x16.png">
    <link rel="manifest" href="assets/manifest.json">
    <link rel="mask-icon" href="assets/safari-pinned-tab.svg" color="#014164">
    <meta name="msapplication-TileColor" content="#014164">
    <meta name="msapplication-TileImage" content="assets/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <!-- Viewport, Google Fonts y CSS -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Alegreya+Sans|Quicksand" rel="stylesheet">
    <link rel="stylesheet" href="assets/index.css">
    <!-- Cononical -->
    <link rel="canonical" href="https://joaquinaraujo.github.io/docker">
</head>
<body>
    <div class="jumbotron">
        <div class="container">
            <h1 class="colorPrimario">Guía del Curso de Docker</h1>
        </div>
    </div>

    <div class="container">
        <section>
            <h2>Introducción a Docker</h2>

            <h3>Introducción y fundamentos de Docker</h3>
            <p><strong>Docker</strong> es una plataforma abierta para que desarrolladores y administradores de sistemas desarrollen, envíen y ejecuten aplicaciones distribuidas, ya sea en computadoras portátiles, maquinas virtuales de centros de datos o en la nube.</p>
            <img src="https://upload.wikimedia.org/wikipedia/commons/7/79/Docker_%28container_engine%29_logo.png" alt="" class="img-responsive">
            <p><strong>Docker</strong> empaqueta software en <strong>"contenedores"</strong> que incluyen en ellos todo lo necesario para que dicho software se ejecute, incluidas librerías. Con <strong>Docker</strong> se puede implementar y ajustar la escala de aplicaciones de una forma rápida en cualquier entorno con la garantía de que el código se ejecutará.</p>
            <p>A primera vista se piensa en <strong>Docker</strong> como una especie de máquina virtual "liviana", pero la verdad no lo es. En <strong>Docker</strong> no existe un <strong>hypervisor</strong> que virtualice hardware sobre el cual corra un sistema operativo completo. En <strong>Docker</strong> lo que se hace es usar las funcionalidades del <strong>Kernel</strong> para encapsular un sistema, de esta forma el proyecto que corre dentro de el no tendrá conocimiento que está en un <strong>contenedor</strong>. Los <strong>contenedores</strong> se encuentran aislados entre sí y se comportaran como máquinas independientes.</p>
            <p>Iniciar un <strong>contenedor</strong> no tiene un gran impacto a diferencia de iniciar una máquina virtual ya que no tiene que iniciar un sistema operativo completo (desde cero). Gracias al uso de <strong>contenedores</strong> la demanda de recursos baja limitándose sólo al consumo de la aplicación que contenga. Un <strong>contenedor</strong> inicia en milisegundos.</p>
            
            <h3>Contenedores y VMs</h3>
            <p>
                Anteriormente hablamos de manera de introducción sobre los <strong>contenedores</strong> pero ahora definamos en sí este concepto, <strong>Docker</strong> trabaja con algo que se llama <strong>"contenedores de Linux"</strong> estos son un conjunto de tecnologías que juntas forman un <strong>contenedor</strong> (de <strong>Docker</strong>), este conjunto de tecnologías se llaman:
                <!-- Lista desordenada -->
                <ul>
                    <li><strong>Namespaces:</strong> Permite a la aplicación que corre en un <strong>contenedor</strong> de <strong>Docker</strong> tener una vista de los recursos del sistema operativo.</li>
                    <li><strong>Cgroups:</strong> Permite limitar y medir los recursos que se encuentran disponibles en el sistema operativo.</li>
                    <li><strong>Chroot:</strong> Permite tener en el <strong>contenedor</strong> una vista de un sistema "falso" para el mismo, es decir, crea su propio entorno de ejecución con su propio <strong>root</strong> y home.</li>
                </ul>
            </p>
            <p>
                Algunas de las características más notables de un <strong>contenedor</strong> son:
                <!-- Lista desordenada -->
                <ul>
                    <li>Los contenedores son más livianos (ya que trabajan directamente sobre el <strong>Kernel</strong>) que las maquinas virtuales.</li>
                    <li>No es necesario instalar un sistema operativo por <strong>contenedor</strong>.</li>
                    <li>Menor uso de los recursos de la máquina.</li>
                    <li>Mayor cantidad de <strong>contenedores</strong> por equipo físico.</li>
                    <li>Mejor portabilidad.</li>
                </ul>
            </p>
            <img src="https://www.redeszone.net/app/uploads/2016/02/docker-vs-virtual-machines.png" alt="Diferencias entre una máquina virtual un un contenedor de Docker" class="img-responsive">
            
            <h3>Instalación</h3>
            <p>
                En este caso veremos como instalar <strong>Docker</strong> en <strong>Linux</strong>, es importante saber que se debe tener un sistema operativo de 64 bits, los pasos son los siguientes:
                <!-- Lista ordenada -->
                <ol>
                    <li>Acceder a <a href="https://get.docker.com/" target="_blank" rel="nofollow">get.docker.com</a></li>
                    <li>Copiar el comando para ejecutar el script.</li>
                    <li>Pegar el comando y ejecutar el script de instalación de <strong>Docker</strong>.</li>
                    <li>Verificar si <strong>Docker</strong> esta instalado con los comando <kbd>docker info</kbd> o <kbd>docker version</kbd></li>
                    <li>Crear un "Hello World" con <strong>Docker</strong> usando el comando <kbd>docker hello-world</kbd></li>
                </ol>
            </p>

            <h3>Docker Engine e Imágenes</h3>
            <p>Una imagen según <strong>Docker</strong> es una plantilla de solo lectura vacía o con un aplicación pre-instalada para la creación de contenedores, estas pueden ser creadas por nosotros o terceros. Se pueden guardar en un registro interno o público, puedes encontrar imágenes en <a href="https://hub.docker.com/" target="_blank" rel="nofollow">hub.docker.com</a></p>
            <img src="http://www.programering.com/images/remote/ZnJvbT1vc2NoaW5hJnVybD1uNUdjdWNETXprVE01ODFkalpXVmZoRE55SWpOeDhTT3hJVE12TVRNd0l6TGxOV1l3TjNMelJXWXZ4R2MxOUNkbDVtTGg1V2FvTjJjdjV5WXBSWFkwTjNMdm9EYzBSSGE.jpg" alt="Imágenes en Docker" class="img-responsive">
            <p>Para descargar imágenes de un repositorio externo, se utiliza en comando <kbd>docker pull</kbd></p>
            <p>Cuando se ejecuta un contenedor con el comando <kbd>docker run</kbd> las imágenes son descargadas automáticamente.</p>
            <p>
                Algunos comandos útiles para el manejo de imágenes y <strong>contenedores</strong> en <strong>Docker</strong> son los siguientes:
                <!-- Lista desordenada -->
                <ul>
                    <li><kbd>docker images</kbd> Lista las imágenes locales.</li>
                    <li><kbd>docker pull [nombre de la imagen]</kbd> Descarga una imagen de <strong>Docker</strong>.</li>
                    <li><kbd>docker pull [nombre de la imagen]:[tag]</kbd> Descarga una imagen de <strong>Docker</strong> con un tag en especifico.</li>
                    <li><kbd>docker ps</kbd> Lista los contenedores que se encuentran en ejecución.</li>
                    <li><kbd>docker ps -a</kbd> Lista todos los contenedores que estén o no en ejecución.</li>
                    <li><kbd>docker ps -a -q</kbd> Lista y muestra sólo los ID de todos los contenedores que estén o no en ejecución.</li>
                    <li><kbd>docker ps -a --no-trunc</kbd> Muestra el formato extendido del ID de los <strong>contenedores</strong>.</li>
                    <li><kbd>docker ps --filter="[tipo de filtrado]"</kbd> Filtra los contenedores en función del código de salida, del estado...</li>
                    <li><kbd>docker ps --help</kbd> Muestra un menú de ayuda.</li>
                    <li><kbd>docker attach [ID/nombre del contenedor]</kbd> Permite ingresar nuevamente a un <strong>contenedor</strong> creado anteriormente.</li>
                    <li><kbd>docker run --name [nombre del contenedor] [imagen]</kbd> Permite iniciar un <strong>contenedor</strong> con un nombre.</li>
                    <li><kbd>docker rm [ID/nombre del contenedor]</kbd> Permite eliminar un <strong>contenedor</strong>.</li>
                    <li><kbd>docker rm [ID/nombre...] [ID/nombre...] [ID/nombre...]</kbd> Permite eliminar más de un <strong>contenedor</strong>.</li>
                    <li><kbd>docker rmi [nombre de la imagen]</kbd> Permite eliminar una imagen.</li>
                    <li><kbd>docker logs [ID/nombre del contenedor]</kbd> Muestra los logs de un <strong>contenedor</strong>.</li>
                    <li><kbd>docker logs -f [ID/nombre del contenedor]</kbd> Muestra los logs en tiempo real de un <strong>contenedor</strong>.</li>
                    <li><kbd>docker exec [opciones] [ID/nombre del contenedor] [comando]</kbd>Permite ejecutar nuevas acciones en un <strong>contenedor</strong>.</li>
                    <li><kbd>docker start -a [ID/nombre del contenedor]</kbd> Permite iniciar nuevamente un <strong>contenedor</strong>.</li>
                    <li><kbd>docker pause [ID/nombre del contenedor]</kbd> Permite pausar un <strong>contenedor</strong> en ejecución.</li>
                    <li><kbd>docker unpause [ID/nombre del contenedor]</kbd> Permite reanudar un <strong>contenedor</strong> pausado.</li>
                    <li><kbd>docker stop [ID/nombre del contenedor]</kbd> Permite detener un <strong>contenedor</strong> en ejecución.</li>
                    <li><kbd>docker kill [ID/nombre del contenedor]</kbd> Permite matar (detener forzosamente) un <strong>contenedor</strong> en ejecución.</li>
                    <li><kbd>docker inspect</kbd> Muestra información útil de un <strong>contenedor</strong>.</li>
                    <li><kbd>docker history [ID/nombre del contenedor]</kbd> Muestra las capas que conforman una imagen con información referente a ella.</li>
                </ul>
            </p>
            <p>Con el comando <kbd>docker run [opciones] [imagen] [comando] [args]</kbd> se creará un contenedor a partir de una imagen. Si <strong>Docker</strong> no consigue la imagen en el área local la descargará.</p>
            <p>
                Por medio de las opciones que se les pasa a los <strong>contenedores</strong>, estos pueden ser interactivos. Algunas muy importantes de conocer son:
                <!-- Lista desordenada -->
                <ul>
                    <li><kbd>-i</kbd> Le indica a <strong>Docker</strong> que se utilizará el <strong>STDIN</strong> del <strong>contenedor</strong>.</li>
                    <li><kbd>-t</kbd> Le indica a <strong>Docker</strong> que se requiere una pseudo-terminal en el <strong>contenedor</strong>.</li>
                    <li><kbd>-d</kbd> Le indica a <strong>Docker</strong> que el <strong>contenedor</strong> correrá en el background.</li>
                    <li><kbd>-P</kbd> Expone los puertos utilizados por un <strong>contenedor</strong>.</li>
                    <li><kbd>-p [puerto "del contenedor":puerto "de la aplicación"]</kbd> Permite establecer un puerto.</li>
                </ul>
            </p>
            <p>Con las combinaciones de teclas <kbd class="black">CNTRL + PQ</kbd> el servicio de <strong>Docker</strong> quedará corriendo en el background.</p>
            <p>
                Existen tres formas de crear imágenes:
                <!-- Lista ordenada -->
                <ol>
                    <li>Hacer <strong>commit</strong> de los contenidos de un <strong>contenedor</strong>: <kbd>docker commit [ID/nombre...] [nombre para la imagen]:[tag]</kbd></li>
                    <li>Construir una imagen basada en un <strong>Dockerfile</strong>.</li>
                    <li>Importar un archivo <strong>Tar</strong> a <strong>Docker</strong> con el contenido de un imagen.</li>
                </ol>
            </p>

            <h3>Dockerfiles</h3>
            <p>Un <strong>Dockerfile</strong> es un documento de texto que contiene todos los comandos que un usuario puede llamar en la línea de comando para armar una imagen.</p>
            <img src="https://runnable.com/images/production/dockerfile.svg" alt="Dockerfile" class="img-responsive" width="300px">
            <p>
                Instrucciones que podría contener un archivo <strong>Dockerfile</strong>:
<pre>
    FROM [imagen]:[tag]
    MAINTAINER joaquinaraujojs@gmail.com
    LABEL "[clave]": "[valor]"
    WORKDIR /[directorio raíz del proyecto]
    COPY [ruta-relativa-del-archivo/carpeta] [destino-del-archivo/carpeta] ./
    ADD [URL del archivo ha descargar]
    RUN [comando] && [comando] && ... && \
    CMD [comando]
    ENTRYPOINT [comando]
    EXPOSE [puerto]
    ENV [variable de entorno]
</pre>
            </p>
            <p>
                Los comandos a continuación permiten la construcción y configuración de una imagen a partir de un documento <strong>Dockerfile</strong>:
                <!-- Lista desordenada -->
                <ul>
                    <li><kbd>docker build [ruta del dockerfile]</kbd> Inicializa la constricción de una imagen a partir de un archivo <strong>Dockerfile</strong>.</li>
                    <li><kbd>docker build -t [nombre-de-la-imagen:tag] [ruta...]</kbd> Permite establecer un nombre y un tag a la imagen a generar.</li>

                </ul>
            </p>

            <h3>Volúmenes</h3>
            <p>Un volumen es un directorio designado en el <strong>contenedor</strong> en el cual la información persiste independientemente del ciclo de vida de dicho <strong>contenedor</strong>.</p>
            <img src="https://docs.docker.com/engine/userguide/storagedriver/images/shared-volume.jpg" alt="Volúmenes en Docker" class="img-responsive">
            <p>
                Algunos comando para gestionar volúmenes en <strong>Docker</strong>
                <!-- Lista desordenada -->
                <ul>
                    <li><kbd>docker volume create --name [nombre]</kbd> Permite crear un volumen y asignarle un nombre.</li>
                    <li><kbd>docker volume ls</kbd> Lista los volúmenes existentes.</li>
                    <li><kbd>docker run -it -v [nombre del volumen]:/[punto/directorio de montaje] [imagen] [comando]</kbd> Permite correr un <strong>contenedor</strong> de forma interactiva que contendrá un volumen.</li>
                    <li><kbd>docker volumen inspect [nombre del volumen]</kbd> Muestra información de interés relacionada al volumen.</li>
                    <li><kbd>docker volumen rm [nombre del volumen]</kbd> Permite eliminar un volumen.</li>
                </ul>
            </p>

            <h3>Aspectos de seguridad en Docker</h3>
            <p>
                Pasos para configurar <strong>Docker</strong> con TLS:
                <!-- Lista desordenada -->
                <ul>
                    <li><kbd>mkdir docker-ca</kbd></li>
                    <li><kbd>cd docker-ca</kbd></li>
                    <li><kbd>openssl genrsa -aes256 -out ca-key.pem 2048</kbd></li>
                    <li><kbd>openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem</kbd></li>
                    <li><kbd>openssl genrsa -out server-key.pem 2048</kbd></li>
                    <li><kbd>openssl req -subj "/CN=[hostname]" -new -key server-key.pem -out server.csr</kbd></li>
                    <li><kbd>echo "subjectAltName = IP:[IP/127.0.0.1]" > extfile.cnf</kbd></li>
                    <li><kbd>openssl x509 -req -days 365 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile.cnf</kbd></li>
                    <li><kbd>openssl genrsa -out client-key.pem 2048</kbd></li>
                    <li><kbd>openssl req -subj "/CN=client" -new -key client-key.pem -out client.csr</kbd></li>
                    <li><kbd>echo "extendedKeyUsage = clientAuth" > extfile.cnf</kbd></li>
                    <li><kbd>openssl x506 -req -days 365 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out client-cert.pem -extfile extfile.cnf</kbd></li>
                </ul>
            </p>
            <p>
                Pasos para asegurar las claves:
                <!-- Lista ordenada -->
                <ol>
                    <li>
                        Asegurar las claves del cliente y el servidor de modo que solo puedan ser leídas por el usuario actual:
                        <kbd>chmod -v 0400 ca-key.pem client-key.pem server-key.pem</kbd>
                    </li>
                    <li>
                        Remover el acceso de escritura a todos los certificados:
                        <kbd>chmod -v 0444 ca.pem client-cert.pem server-cert.pem</kbd>
                    </li>
                    <li>Crear la carpeta <strong>/etc/docker</strong> en caso de que no exista.</li>
                    <li>
                        Cambiar los permisos de la carpeta <strong>/etc/docker</strong>:
                        <kbd>sudo chown <span class="arrows">username</span>:docker /etc/docker</kbd>
                        <kbd>sudo chmod 700 /etc/docker</kbd>
                    </li>
                    <li>
                        Copiar las claves del servidor a la nueva carpeta:
                        <kbd>sudo cp ~/docker-ca/{ca, server-key, server-cert}.pem /etc/docker</kbd>
                    </li>
                </ol>
            </p>
            <p>
                Pasos para usar <strong>Docker</strong> con TLS:
                <!-- Lista ordenada -->
                <ol>
                    <li>
                        Iniciar el servicio con los siguientes parámetros:
<pre>
    DOCKER_OPTS="-H tcp://0.0.0.0:2376 --tlsverify --tlscacert=/etc/docker/ca.pem --tlscert=/etc/docker/server-cert.pem --tlskey=/etc/docker/server-key.pem" &
</pre>
                    </li>
                    <li>
                        Reiniciar el servicio de <strong>Docker</strong> en caso de ser necesario:
                        <kbd>sudo service docker restart</kbd>
                    </li>
                    <li>
                        Utilizar las credenciales correspondientes en el cliente (carpeta docker-ca):
<pre>
    docker --tlsverify --tlscacert=./ca.pem --tlscert=./client-cert.pen --tlskey=./client-key.pem -H tcp://127.0.0.1:2376
</pre>
                    </li>
                </ol>
            </p>

            <h3>Redes</h3>
            <p>Por defecto, al instalar <strong>Docker</strong> en <strong>Linux</strong> se crea una interfaz de red virtual llamada <strong>docker0</strong> en el equipo host.</p>
            <p>
                El comando <kbd>docker network</kbd> permite interactuar con las redes de <strong>Docker</strong> y los contenedores dentro de ellas, unos comandos importantes a tomar en cuenta son:
                <!-- Lista desordenada -->
                <ul>
                    <li><kbd>docker network create [nombre de la red]</kbd> Permite crear una red.</li>
                    <li><kbd>docker network connect [nombre de la red][nombre del contenedor] </kbd> Permite conectar un contenedor de una red.</li>
                    <li><kbd>docker network ls</kbd> Lista las redes existentes.</li>
                    <li><kbd>docker network rm</kbd> Permite eliminar una red.</li>
                    <li><kbd>docker network disconnect</kbd> Permite desconectar un contenedor de una red.</li>
                    <li><kbd>docker network inspect</kbd> Muestra información de interés sobre las redes de <strong>Docker</strong>.</li>
                    <!-- <li><kbd>docker network </kbd></li> -->
                    <li><kbd>--net [nombre de la red]</kbd> Utilizar esta bandera al crear un <strong>contenedor</strong> permite especificar la red en la cual estará dicho <strong>contenedor</strong>.</li>
                    <li><kbd>--link [nombre del contenedor]</kbd> Permite enlazar dos <strong>contenedor</strong> y así comunicarse entre ellos por medio de su nombre.</li>
                </ul>
            </p>
            <img src="https://docs.docker.com/engine/userguide/networking/images/working.png" alt="Redes de Docker" class="img-responsive">
            <p>La red <strong>bridge</strong> es la que utilizan todos los <strong>contenedores</strong> por defecto, la <strong>host</strong> permite que los <strong>contenedores</strong> compartan la misma IP que la del equipo host.</p>
        
            <h3>Docker Machine</h3>
            <p><a href="https://github.com/docker/machine/releases" target="_blank">Machine</a> es una herramienta para provisionar hosts de <strong>Docker</strong> y configurar el Engine en los mismos.</p>
            
            <h3>Docker Compose</h3>
            <p><a href="https://github.com/docker/compose/releases" target="_blank">Compose</a> es una herramienta para crear y administrar aplicaciones multi-contenedor.</p>
            <p>Los microservicios son aplicaciones individuales que tiene un comportamiento independiente y hablan un protocolo en común, por ejemplo, JSON sobre HTTP.</p>
            <img src="https://foxutech.com/wp-content/uploads/2017/06/docker-compose1.png" alt="Docker compose" class="img-responsive">
            <p>En una arquitectura de microservicios existen muchos servicios, por tal motivo tiene múltiples componentes para correr.</p>
            <p><strong>docker-compose.yml</strong> define los servicios que componeme la aplicación y cada servicio contiene las instrucciones para construir y ejecutar el contenedor.</p>
<pre>
    web:
        build: [ubicación del archivo Dockerfile]
        links:
            - [nombre del contenedor a enlazar]
        ports:
    #   expose:
    #       - "[puerto en el que escucha la aplicación]"
            - "[puerto en el que escuchará el contenedor]:[puerto en el que escucha la aplicación]"
    redis:
        image: [nombre de la imagen]
    # lb:
    #     image: dockercloud/haproxy:latest
    #     links:
    #         - web
    #     ports:
    #         - "80:80"
    #     environment:
    #         - BACKEND_PORT=5000
    #         - BALANCE=roundrobin
</pre>

            <p>
                Algunos comandos para gestionar de Docker-compose son:
                <!-- Lista desordenada -->
                <ul>
                    <li><kbd>docker-compose up</kbd> Inicia los microservicios definidos en <strong>docker-compose.yml</strong>.</li>
                    <li><kbd>docker-compose up -d</kbd> Inicia los microservicios definidos en <strong>docker-compose.yml</strong> y correr los <strong>contenedores</strong> en el background.</li>
                    <li><kbd>docker-compose build</kbd> Construye desde 0 los microservicios si se realizó algún cambio.</li>
                    <li><kbd>docker-compose logs</kbd> Muestra todos los logs de todos los servicios.</li>
                    <li><kbd>docker-compose logs [nombre del microservicio]</kbd> Muestra los logs de un servicio en particular.</li>
                    <li><kbd>docker-compose rm [microservicio]</kbd> Permite eliminar un servicio, siempre y cuando este se encuentre detenido.</li>
                    <li><kbd>docker-compose stop</kbd> Permite detener todos los microservicios que se encuentren en ejecución.</li>
                    <li><kbd>docker-compose down</kbd> Detiene todos los microservicios y los elimina que se encuentren en ejecución.</li>
                    <li><kbd>docker-compose help</kbd> Muestra un menú de ayuda con todos los comandos de <kbd>docker-compose</kbd></li>
                    <li><kbd>docker-compose -f [docker-compose].yml [comando]</kbd> Permite usar un archivo de configuración de docker-compose.yml con otro nombre.</li>
                    <!-- <li><kbd>docker-compose </kbd></li> -->
                </ul>
            </p>
            <p> En una arquitectura de microservicios, generalmente tenemos la ventaja de poder escalar un servicio específico para soportar la carga.
                <!-- Lista desordenada -->
                <ul>
                    <li><kbd>docker-compose scale [servicio]=[instancias de escalar]</kbd> Permite escalar servicios (mapeados en puertos distintos).</li>
                </ul>
            </p>

            <h3>Redes multi-host y Docker Swarm</h3>
            <p>Los <strong>contenedores</strong> que corren en diferentes hosts no pueden comunicarse entre sí a menos que expongan sus puertos mediante el host. Multi-host networking habilita a que <strong>contenedores</strong> en diferentes hosts puedan comunicarse sin necesidad de exponer sus puertos.</p>
            <img src="https://devopscube.com/wp-content/uploads/2016/02/Docker-1.9-container-networking.png" alt="Multi-hosts networking de Docker" class="img-responsive">
            <p>El <strong>Docker</strong> engine permite realizar multi-hosts networking nativamente mediante el <strong>driver overlay</strong> de red.</p>
            <p><strong>Docker swarm</strong> permite formar clusters de <strong>Docker</strong> hosts y decide dónde lanzar los <strong>contenedores</strong> (scheduler).</p>
            <p>
                Algunas de sus características son:
                <!-- Lista desordenada -->
                <ul>
                    <li>Presenta varios hosts de <strong>Docker</strong> como si fueran uno solo.</li>
                    <li>Permite distribuir <strong>contenedores</strong> por varios equipos dentro del cluster.</li>
                    <li>Utiliza la API standard de <strong>Docker</strong>.</li>
                    <li>Incluye una política simple de programación de <strong>contenedores</strong> y descubrimiento.</li>
                </ul>
            </p>
            <p>Cuando se crea una nueva red en una maquina que no pertenece a un <strong>swarm</strong> la red por defecto es <strong>bridge</strong>, en cambio cuando la maquina pertenece a un <strong>swarm</strong> la red por efecto es <strong>overlay</strong>.</p>

        </section>

        <section>
            <div id="disqus_thread" class="disqus"></div>
        </section>
    </div>

    <!-- Pie de página -->
    <footer>
        <!-- Sobre el autor @JoaquinAraujoJS -->
        <div class="container">
            <div class="row">
                <div class="col-sm-8">
                    <h3 class="text-center">Acerca del autor</h3>
                    <p class="foo text-center">Hola, mi nombre es <strong>Joaquin Araujo</strong>, soy Venezolano, natal de la cálida y soleada ciudad de <strong>Maracaibo</strong>. Soy de los que apuesta por <strong>JavaScript</strong> porque sencillamente <strong>¡JavaScript se comió al mundo!</strong> Me enfoco más al área del backend (con <strong>Nodejs</strong>).</p>
                    <p class="foo text-center"><strong>No me limito a aprender cosas nuevas</strong> ya que siempre ando en constante aprendizaje. <strong>Me gusta compartir lo que aprendo</strong> es por ello que realicé esta guía.</p>
                    <p class="foo text-center">Si quieres comunicarte conmigo puedes hacerlo a través de mi cuenta en twitter <strong><a href="https://twitter.com/JoaquinAraujoJS" target="_blank">@JoaquinAraujoJS</a></strong>. Estoy abierto a cualquier proyecto <strong>¡con ganas de cambiar al mundo!</strong></p>
                </div>
                <div class="col-sm-4">
                    <img src="https://avatars0.githubusercontent.com/u/20958348?v=4&s=460" alt="Joaquin Araujo" class="img-rounded">
                </div>
            </div>
        </div>
        <!-- Créditos a Platzi -->
        <div class="container-fluid">
            <p class="text-center colorPrimario">Esta guía fue realizada por <a href="https://twitter.com/JoaquinAraujoJS" target="_blank" class="colorPrimario">Joaquin Araujo</a> y es un resumen del <a href="https://platzi.com/cursos/docker/" target="_blank" class="colorPrimario">Curso de Docker</a> de <a href="https://platzi.com" target="_blank" class="colorPrimario">Platzi</a></p>
        </div>
    </footer>

    <!-- Caja de comentarios Disqus (Script) -->
    <script>
    var disqus_config = function () {
        this.page.url = 'https://joaquinaraujo.github.io/docker';
        this.page.identifier = window.location.pathname;
        this.page.title = 'Guía del Curso Docker';
    };

    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://joaquin-araujo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Por favor, active JavaScript para ver el <a href="https://disqus.com/?ref_noscript">comentarios impulsados por Disqus.</a></noscript>
    <script id="dsq-count-scr" src="//joaquin-araujo.disqus.com/count.js" async></script>
</body>
</html>